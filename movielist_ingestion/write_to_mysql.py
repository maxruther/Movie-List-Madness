import pymysql.connections

from .drop_tables import drop_obsolete_og_tables
from .compose_sql_stmts import create_table_stmt, table_insert_stmts


def build_core_mysql_tbls(data: list[list[str | list[str | int]]],
                          db: pymysql.connections.Connection
                          ) -> None:
    """In the MySQL db, (re)creates from scratch the 'og' and
    'AllMovies' tables from those in the data given.

    The 'og' tables each represent a table in the original (or 'og')
    Evernote HTML. The resultant MySQL table names will match those of
    the original Evernote ones (e.g. 'Comedies' -> 'comedies_og').

    What I refer to as the 'AllMovies' tables are the 'AllMovies',
    'allUnwatched', and 'allWatched' tables. The latter two derive from
    the former, which is simply a master list of all unique movies
    featured in the original Evernote tables.

    NOTE: Existing MySQL tables are DELETED & RECREATED if they share
    a name with an Evernote table. This is not a process that appends
    or updates existing MySQL tables."""

    # Build out the 'og' tables, writing the 3D list's data to the MySQL
    # database. Preexisting 'og' tables are dropped before new ones are
    # here built from scratch.
    build_og_tbls(data, db)

    # Build out the 'AllMovies' tables, in the same fashion of first
    # deleting any preexisting such tables.
    build_allmovies_tbls(data, db)


def build_og_tbls(data: list[list[str | list[str | int]]],
                  db: pymysql.connections.Connection
                  ) -> None:
    """From the given 3D list of movie data, build a table in MySQL for
    each listed therein. In MySQL, the names of these tables will be
    appended with '_og', to indicate that they reflect the originals."""

    # Create cursor from the db connection
    cursor = db.cursor()

    # This process drops all existing tables before recreating them. In
    # order to do so, the OMDB-related tables must be dropped first, as
    # they are child relations to the 'allmovies' table.
    omdb_tables = ['omdb', 'genres', 'critic_ratings']
    for table in omdb_tables:
        cursor.execute("DROP TABLE IF EXISTS " + table)

    if not drop_obsolete_og_tables(data, cursor):
        raise Exception("CANCELLING UPDATE OF MySQL DATABASE\n"
                        "The user declined to delete the remnant and"
                        "obsolete 'og' tables, a necessary step to"
                        "(re)building the MovieDB tables.")

    # Every table from the given data, as processed from file by
    # 'read_from_evernote_html()', is rebuilt in a MySQL one from
    # scratch.
    table_count = len(data)
    for i in range(table_count):
        # Delete the existing table in MySQL if it shares this Evernote
        # table's name.
        curr_table_name = data[i][0][0]
        cursor.execute("DROP TABLE IF EXISTS " + curr_table_name)

        # Create a table in MySQL for this Evernote table.
        #
        # ERROR NOTE: If an Evernote table has unnamed columns, errors
        # will here arise.
        # print(create_table_stmt(i, data))
        cursor.execute(create_table_stmt(i, data))

        # Insert a row for each of this table's movie records.
        for k in table_insert_stmts(i, data):
            # print("CURR INS STATEMENT: " + k)
            cursor.execute(k)

        db.commit()


def build_allmovies_tbls(data: list[list[str | list[str | int]]],
                         db: pymysql.connections.Connection
                         ) -> None:
    """From the 3D list of Evernote watchlist data, clears and rebuilds
    the 'AllMovies' tables by calling SQL procedures that were
    pre-defined in the Movie DB.

    These procedure definitions can be found in this file:
    '../'SQL files'/'SQL Proc Definitions - MovieList.sql'"""

    # Create cursor from the db connection
    cursor = db.cursor()

    # Once all the tables are read in, a few more MySQL tables are
    # generated by SQL procedures that I've defined in advance.

    # Create table 'allunwatched', containing all movies that I've yet
    # to watch.
    cursor.callproc('generateUnwatched')

    # Create table 'allwatched', containing all the listed movies that I
    # have watched.
    cursor.callproc('generateWatched')

    # Create table 'allmovies', which simply contains all movie records,
    # regardless of whether they're of ones I've yet watched.
    cursor.callproc('generateAllMovies')

    db.commit()
