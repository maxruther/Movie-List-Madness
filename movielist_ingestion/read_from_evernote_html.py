from bs4 import BeautifulSoup


def read_evernote_tbls_to_3d_list(filename: str
                                  ) -> list[list[str | list[str | int]]]:
    """Reads in my movie list, which is exported from Evernote in HTML
    format. Uses BeautifulSoup to parse the content."""
    with open(filename, errors='ignore') as f:
        soup = BeautifulSoup(f, "html.parser")

    # The movie list is composed of roughly a dozen tables, which
    # variously represent anticipated films, specific genres, and
    # favorite or nostalgic films.

    # Reading in the names of each of the tables, which are identified
    # by their being 'h2' elements. Each of these tables in the Evernote
    # file will have a corresponding table in the MySQL database.
    table_names = []
    all_h2_headers = soup.find_all(name="h2")
    for header in all_h2_headers:
        header_name = header.text[0:-1].replace(" ", "_") + "_og"
        table_names.append(header_name)

    # Next, read in the tables' entries.

    # Storing this data in a 3D list, where each table is associated
    # with a 2D-list of its entries.
    data = []
    table_ind = 0
    # The movie_id will uniquely identify the movies. The first entry
    # featured in the movie list HTML is always #1.
    movie_id = 1
    movie_dict = {}
    for table in soup.find_all("en-table"):
        # Create a 2D list, where the first element is the table's name
        curr_table = [[table_names[table_ind]]]
        table_ind += 1
        row_num = 0
        # Iterate through each row of the Evernote table (represented by
        # <tr> elements) and also the cells of those rows (represented
        # by <td> elements.
        for row in table.find_all("tr"):
            curr_row = []
            data_elements = row.find_all("td")
            for element in data_elements:
                curr_elem = element.text

                # This 'li_found' block handles the 'Watched' attribute
                # of the movie table, which is an interactive checkbox
                # in Evernote.
                li_found = element.find("li")
                if li_found:
                    # If an <li> object shows 'True' for its
                    # 'data-checked' value, that indicates that it's a
                    # checkbox.
                    if li_found["data-checked"] == "true":
                        curr_elem = 1
                    else:
                        curr_elem = 0

                # If the current element is blank, it is recorded as
                # 'NULL' in the data, for SQL.
                elif curr_elem == '':
                    curr_elem = "NULL"

                # String elements that containing a single-quote
                # character are enclosed in double-quotes (and vice
                # versa) for easy insertion into SQL tables.
                elif isinstance(curr_elem, str):
                    # Column header strings are here reformatted, to
                    # better serve as field names in SQL.
                    if row_num == 0:
                        curr_elem = curr_elem.replace(" ", "_")
                        curr_elem = curr_elem.replace("Awesome?", "Rating")

                    # Non-header string elements are here checked for
                    # apostrophes. If apostrophes are present, then the
                    # string is instead enclosed in double-quotes, for
                    # the eventual SQL 'INSERT' statements.
                    elif row_num > 0:
                        if "'" in curr_elem:
                            curr_elem = '"' + curr_elem + '"'
                        else:
                            curr_elem = "'" + curr_elem + "'"

                # Appending the element to that row's list of data,
                # which is ultimately appended to the 2D table-list upon
                # completion.
                curr_row.append(curr_elem)
            if row_num == 0:
                # 'Movie_ID', an attribute generated by this process,
                # is prepended to the list of the table's native attributes.
                curr_row = ['Movie_ID'] + curr_row
            else:
                # Handle duplicate entries, which are numerous. If a
                # combination of film title and director have already
                # been processed, then that existing record is retrieved
                # in place of the newly-ingested, duplicate record.
                title_and_dir = curr_row[0] + curr_row[1]
                if movie_dict.get(title_and_dir, -1) == -1:
                    curr_row = [movie_id] + curr_row
                    movie_dict[title_and_dir] = movie_id
                    movie_id += 1
                else:
                    curr_row = [movie_dict.get(title_and_dir)] + curr_row

            # print(curr_row.copy())
            curr_table.append(curr_row.copy())
            row_num += 1

        # A copy of the table's data is then appended to the master list
        # of table data, 'data'.
        data.append(curr_table.copy())

    return data
