import pandas
import pandas as pd
from sqlalchemy import create_engine
from typing import Self


class ReviewTableMender:
    """Puts the finishing touches on the critic_ratings table
    by 1) filling in missing Metacritic and Rotten Tomatoes
    reviews and 2) adding the Ebert ratings (from file.)"""

    # Various mappings to fill in wrongfully missing review scores.
    from critic_ratings.reviewer_mappings import metacritic_mapping, rt_mapping

    def __init__(self, db_path: str) -> None:
        self.isConnected = False
        self.conn = None
        self.engine = None
        self.db_path = db_path

        self.cr_df: pandas.DataFrame = pd.DataFrame()

    def set_db_path(self, db_path: str) -> None:
        self.db_path = db_path

    def connect_to_db(self) -> None:
        self.engine = create_engine('mysql://root:yos@localhost/moviedb')
        self.conn = self.engine.connect()
        self.isConnected = True

    def disconnect_from_db(self) -> None:
        self.engine.dispose()
        self.conn.close()
        self.isConnected = False

    def get_critic_ratings_tbl(self):
        if not self.isConnected:
            raise Exception("ERROR - ReviewTableMender - You cannot"
                            "get the critic ratings table before first"
                            "connecting to the db (via connect_to_db() "
                            "method called with valid db path.)")

        query = "SELECT * FROM critic_ratings"
        self.cr_df = pd.read_sql_query(query, self.engine,
                                       index_col='Movie_ID')

    def fill_missing_metacritic(self) -> Self:
        """Fills in some missing Metacritic scores by applying a
        mapping. (Also contains functionality to identify such missing
        scores and print out a mapping formatted for user entry.)"""

        # Read 'critic_ratings' table from MySQL db into self.cr_df ,
        # if not yet done.
        if self.cr_df.empty:
            raise Exception("ERROR - Before running "
                            "fill_missing_metacritic(), the "
                            "critic_ratings table must be fetched with"
                            "get_critic_ratings_tbl().")

        # Apply the mapping to the missing reviews.
        self.cr_df['MetaC_Score'] = self.cr_df['MetaC_Score'].fillna(
            self.cr_df['Title'].map(self.metacritic_mapping)
        )

        # Load this amended table to the MySQL db, replacing the
        # preexisting one.
        self.cr_df.to_sql('critic_ratings', self.engine,
                          if_exists='replace', index=True)

        return self

    def fill_missing_rt(self) -> Self:
        """Fills in some missing RottenTomatoes scores by applying a
        mapping. (Also contains functionality to identify such missing
        scores and print out a mapping formatted for user entry.)"""

        # Read 'critic_ratings' table from MySQL db into self.cr_df ,
        # if not yet done.
        if self.cr_df.empty:
            self.get_critic_ratings_tbl()

        # Apply the mapping to the missing reviews
        self.cr_df['RT_Score'] = self.cr_df['RT_Score'].fillna(
            self.cr_df['Title'].map(self.rt_mapping)
        )

        # Load this amended table to the MySQL db, replacing the
        # preexisting one.
        self.cr_df.to_sql('critic_ratings', self.engine, if_exists='replace',
                          index=True)

        return self

    def join_in_ebert_ratings(self,
                              ebert_filepath: str = None,
                              ) -> Self:
        """Read in the ebert_ratings.csv and right-join it to the
        critics_ratings table."""

        if not self.isConnected:
            raise Exception("ERROR - ReviewTableMender - You cannot"
                            "get the critic ratings table before first"
                            "connecting to the db (via connect_to_db() "
                            "method called with valid db path.)")

        # Read 'critic_ratings' table from MySQL db into self.cr_df ,
        # if not yet done.
        if self.cr_df.empty:
            self.get_critic_ratings_tbl()

        # Read in the Ebert ratings from file
        if ebert_filepath:
            ebert_df = pd.read_csv(ebert_filepath,
                                   index_col='Movie_ID')
        else:
            ebert_df = pd.read_csv('data/ebert_ratings.csv',
                                   index_col='Movie_ID')

        # Change 'Year' attribute's type to string (from int).
        ebert_df['Year'] = ebert_df['Year'].astype(str)

        # Join the Ebert ratings onto the critic_ratings df
        cr_plus_ebert_df = self.cr_df.merge(ebert_df, how='left',
                                            on=['Title', 'Year'])
        cr_plus_ebert_df.index = range(1, len(cr_plus_ebert_df) + 1)
        cr_plus_ebert_df.index.names = ['Movie_ID']

        # Load this amended table to the MySQL db, replacing the
        # preexisting one.
        cr_plus_ebert_df.to_sql('critic_ratings', self.engine,
                                if_exists='replace', index=True)

        return self

    def report_missing_reviews(self, reviewer: str = 'all') -> None:
        """Prints reports of the films missing review scores, in the
        form of mappings-to-be, value-less dictionary literals ready for
        manual entry.

        Reviewers include 'metacritic', 'rotten tomatoes', and 'ebert'.
        The default value for the reviewer parameter, 'all', will print
        reports for all these.
        """

        valid_reviewer_entries = ['all',
                                  'metacritic',
                                  'rotten tomatoes',
                                  'ebert']

        if reviewer not in valid_reviewer_entries:
            raise Exception("ERROR: Invalid entry for 'reviewer' in "
                            "report_missing_reviews() call.")

        reviewer_var_dicts = {
            'ebert': {'mysql field name': 'Ebert_Score',
                      'reviewer name': 'Ebert',
                      'mapping varname prefix': 'ebert'},

            'metacritic': {'mysql field name': 'MetaC_Score',
                           'reviewer name': 'Metacritic',
                           'mapping varname prefix': 'metacritic'},

            'rotten tomatoes': {'mysql field name': 'RT_Score',
                                'reviewer name': 'Rotten Tomatoes',
                                'mapping varname prefix': 'rt'},
        }

        reviewer_var_set = []
        if reviewer == 'all':
            for each_reviewer in reviewer_var_dicts:
                reviewer_var_set.append(
                    reviewer_var_dicts[each_reviewer]
                )
        else:
            reviewer_var_set.append(
                reviewer_var_dicts[reviewer]
            )

        for rev_vars in reviewer_var_set:
            query = """
            SELECT Movie_ID, Title FROM (
                SELECT c.Movie_ID, c.Title, a.Release_Date
                FROM critic_ratings c INNER JOIN allmovies a
                ON c.Title=a.Title
                WHERE c.""" + rev_vars['mysql field name'] + """ IS NULL
                ORDER BY a.Release_Date DESC
                ) AS tt;
                """

            missing_reviews_df = pd.read_sql_query(query, self.engine,
                                                   index_col='Movie_ID')

            # Print the film titles in the format of a python dict
            # literal, ready for my manual data entry.
            print("\n\nREPORTING MISSING "
                  + rev_vars['reviewer name'].upper() +
                  " RATINGS\n"
                  "Value-less dictionary literal for the films missing "
                  "ratings:\n")

            print(rev_vars['mapping varname prefix'] + "_mapping" +
                  " = {")
            for i in missing_reviews_df.values:
                print(f'\t"{i[0]}": ,')
            print("\t}")
