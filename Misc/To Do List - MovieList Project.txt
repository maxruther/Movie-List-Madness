Movie List Project
------------------

SCRAPER ORGANIZATION:

metacritic_cr_scrape.py - Given a dataframe of films and links to their Metacritic movie pages, scrape the individual reviews from critics that make up the films' aggregate 'Critical Review' scores.




TO DO:

- The scraper that retrieves the metacritic film links should draw from the MySQL db to inform that search, rather than draw from the Letterboxd links. No? Or both.
	- There are a few dozen movies that weren't scraped for Metacritic CR's because they aren't in my LetterBoxd diary, because they lack 'watch_dates' in my original data (in Evernote.)

- The movie 'Adaptation' needs to be retitled to 'Adaptation.' (that period is part of it) in my Evernote movie list.

- Change the reporting of missing ratings so that the results omit the films that I verified as unrated.
	- This might involve including an empty value in their map entries (instead of only acknowledging such films
	  in comments.
	- Then the reporting function(s) can scan the 

- If 'Watched' is '1', then 'Rating' shouldn't really ever be null. I need to write a phrase that describes my feeling of when I'm unmoved by a movie. Perhaps 'NAH'.

- The module/method read_from_evernote_html.py should probably raise errors when key fields are empty, like title and year. When year is empty, it causes an error in one of the tests, test_for_movieid_discrepancies.
	- Another test: make sure WatchDate is within the last several years.



- The 'allmovies' table should have the native_ordering attribute removed. It's distracting and unhelpful outside of each 'og' table.

- The SQL tables' attributes (or perhaps the Evernote ones) need to have consistent case. When queries are read into dataframes, the attribute's cases are those specified in the MySQL create table statements. Pandas is case sensitive when selecting features, while SQL isn't.

- I may need to overhaul how I enter 'Release Date' values into my Evernote file.


- Investigate whether pymysql interfaces with pandas in some way that I've missed.

- Create a python method (or multiple) that test the ingested data for inconsistencies between duplicate film entries. In my 'Rating' attribute, one Pride & Prejudice entry showed "NONE" while the other showed "GREAT". Gotta test for these, and report failures.

- SQL-Constrain rating fields to decimals between 0 and 1, inclusive? (SQL & 'omdb builder.py')



BIG TO DO:

- Get Josh Larsen's movie ratings and incorporate them into the critic_ratings table.

- Use Pandas instead of "list[list[str | list[str | int] ] ]" ?

- Recode OMDB_builder.py so that it only requests records for the newly added movies?

- Does the primary key need to be considered more intentionally?
	- Might it be problematic for analysis that the Movie_ID s reindexed at every new processing of the 		watchlist?



ANALYSIS TO DO:

- The SQL queries should select the least fields necessary to the ensuing analysis. Feature selection that can be done at the outset should be done prior, in these queries.

- Make a whole Jupyter NB dedicated to EDA of the movie data?



EVERNOTE TO DO

- Leverage Evernote API, which I now have access to.

- Make the film 'Monica' a favorite.



FINE FINE-TUNING

- Once the Ebert file is updated (or a mapping is created to make sure new Ebert ratings get filled) then it might be worth rerunning the first Jupyter notebook, specifically its Ebert section towards the end.


SQL:





DONE

- Rewrote and HTML-printed the first jupyter notebook, "Fixing the CR Table.ipynb" (CR = critic_ratings). It does much to document the part of the process concerning my py package critic_ratings.

- Added error reporting for when an OMDB-returned record shows 'N/A' for runtime. (This case usually suggests that OMDb did not match the correct film to the year and title that I provided in my Evernote list.) Now when this error occurs, the probably-mismatched movie's title and year are printed. (Though it's the OMDB title and year. Evernote-specified title and year would be better, if available at that juncture.)

- Recoded the various fill_mapping_blank() functions into one, fill_mapping(). Uses the same idioms as the reporting_missing() method to do so.

- If a film is missing a value in its 'Year' field in the Evernote file, then test_movieid_key_discrepancies() will raise an error.

9/17/24

- Refactor movie_list_ingestor into a package of multiple modules

- The Jupyter NB's need to be moved to their corresponding subdir and the relative filepaths they reference need to be adjusted accordingly.

- Add exception to create_table_stmt() in movielist_ingestion.compose_sql_stmts.py . This must raise the error described in the docstring, one triggered by the occurrence of an unnamed column in an Evernote table.

9/11/24

- Refactor ReviewTableMender further, so that its functions are intuitively grouped into separate files

- In SQLStatingMovieData.py , the drop_table_stmt() method is pretty unnecessary.

- Rename 'pickled_OMDB_dicts.data' and its references to 'OMDB_data_raw.data'

- In review_table_mender,he 'report_missing_...' methods are nearly identical. Code this so that one can simply pass the parameter of the review type to get the appropriate report printed.

- Test ReviewTableMender reporting functions

- Fixed filepaths in the pickling methods, which were breaking down after I heavily refactored and modularized the code.

9/9/24 - 9/10/24

- Added checks to help ensure against discrepancies between the keys of the added and loaded movie records. Done to address this situation: "When a new movielist with added movies is processed by movie_list_ingestor, but the omdb_builder method doesn't request new OMDB records through the API, there will be INCONGRUITY BETWEEN THE TABLES' KEYS."

9/3/24


- Script 'recreate_movie_list_db.py' now runs the following scripts' main methods, in proper sequence: movie_list_ingestor.py, omdb_builder.py, and amend_CR_table.py .
- Rename 'omdb_abrvd' table to 'omdb' ?
- The "gnr8_2d_data_genre" method should simply make the attributes/header the first row in the data
  it returns. Then the "gnr8_table" methods should simply reference that first row when constructing
  the 'CREATE TABLE' statement.
- Implement error in get_omdb_data(), so that invalid 'method' results in error, rather than None return.
- Have genre table use Movie ID as a foreign key, referencing allmovies table. (Currently coded
  but commented out, and I'm unsure of its correctness.)
- Function signatures classed up, proper.
- Function descriptions should be in triple-quotes for docustring functionality.
- UPDATE PROCEDURE DEFINITIONS in the SQL files!! Have them match what's shown in MySQL Workbench.
- In movie_list_ingestor.py , add comments to the methods that generate SQL statements for the Evernote data.
- Put SQL-statement generators in separate file, to be imported.
- The review_remedies need each be defined as functions rather than statements that will run upon import.
- The Ebert file should be changed so that '-1' values are instead simply missing, or NA.
- Refine the "Amending_CR_table" document so that it includes and explains the various processes that
  put the finishing touches on the critic_ratings table.
- Add RT_Score amending for the critic_ratings table.
- Request Developer token from Evernote
- The Python ingestion script needs to run the getWatched() procedure. (Should be quick.)
- Create a procedure that generates allUnwatched
- The SQL procedures can be defined in SQL scripts, but the Python script should handle the running of things.
- Consider aggregating unwatched movies from non-backburning tables into an allUnwatched
	- Have the aggregating procedure assign 'priority rank' based on the 'og' source table.

- Make it so that the "og" movie tables are automatically generated with the proper constraints:
	- Constrain "Watched" and "Watched in theater" domain to values 1 and 0 only.
	- Make Primary Key out of Title + Director

- Add a "native index" attribute during ingestion, so that the original ordering of the tables can be recreated in SQL.

- Create a stored procedure, "getWatched()", that creates an " allWatched table that lists all watched movies. It must always expect duplicates amongst the tables, as such duplicate entry is the current method of attributing genre.
	- It was a little tricky adjusting to the MySQL syntax for defining procedures, particularly for loops using cursors. I was also slow to see the critical importance of changing the Delimiter setting away from ';'.
	- It was VERY tricky getting the prepared statement to work, so that I could query tables that are only provided at runtime.
	- 